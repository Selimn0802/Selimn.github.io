<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>final关键字</title>
      <link href="/2025/03/27/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2025/03/27/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p><code>final</code> 关键字在 Java 中主要用于修饰<strong>变量、方法和类</strong>，用来表示<strong>不可更改</strong>的特性。具体用法如下：</p><hr><h2 id="1-修饰变量（常量）"><a href="#1-修饰变量（常量）" class="headerlink" title="1. 修饰变量（常量）"></a>1. 修饰变量（常量）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑final int MAX_VALUE = 100;<br>MAX_VALUE = 200; // ❌ 编译错误，不能修改 final 变量<br></code></pre></td></tr></table></figure><ul><li><strong>修饰基本数据类型</strong>：值不能被修改。</li><li><strong>修饰引用类型</strong>：引用地址不能修改，但对象的内容可以更改。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑final List&lt;String&gt; list = new ArrayList&lt;&gt;();<br>list.add(&quot;Hello&quot;);  // ✅ 可以修改内容<br>list = new ArrayList&lt;&gt;();  // ❌ 不能修改引用地址<br></code></pre></td></tr></table></figure><hr><h2 id="2-修饰方法（防止方法被重写）"><a href="#2-修饰方法（防止方法被重写）" class="headerlink" title="2. 修饰方法（防止方法被重写）"></a>2. 修饰方法（防止方法被重写）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑class Parent &#123;<br>    final void show() &#123;<br>        System.out.println(&quot;Parent show&quot;);<br>    &#125;<br>&#125;<br><br>class Child extends Parent &#123;<br>    // ❌ 编译错误，不能重写 final 方法<br>    void show() &#123; <br>        System.out.println(&quot;Child show&quot;); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-修饰类（防止类被继承）"><a href="#3-修饰类（防止类被继承）" class="headerlink" title="3. 修饰类（防止类被继承）"></a>3. 修饰类（防止类被继承）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑final class Animal &#123;<br>    void speak() &#123;<br>        System.out.println(&quot;Animal speaks&quot;);<br>    &#125;<br>&#125;<br><br>// ❌ 编译错误，不能继承 final 类<br>class Dog extends Animal &#123; <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-final-关键字的特殊用法"><a href="#4-final-关键字的特殊用法" class="headerlink" title="4. final 关键字的特殊用法"></a>4. final 关键字的特殊用法</h2><h3 id="（1）修饰成员变量（必须初始化）"><a href="#（1）修饰成员变量（必须初始化）" class="headerlink" title="（1）修饰成员变量（必须初始化）"></a>（1）修饰成员变量（必须初始化）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑class Test &#123;<br>    final int num; // 必须在构造器或代码块中初始化<br><br>    Test(int num) &#123;<br>        this.num = num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（2）修饰方法参数（参数值不能被修改）"><a href="#（2）修饰方法参数（参数值不能被修改）" class="headerlink" title="（2）修饰方法参数（参数值不能被修改）"></a>（2）修饰方法参数（参数值不能被修改）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑void print(final int x) &#123;<br>    x = 20; // ❌ 编译错误<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（3）配合-static-final（常量）"><a href="#（3）配合-static-final（常量）" class="headerlink" title="（3）配合 static final（常量）"></a>（3）配合 <code>static final</code>（常量）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java<br><br><br>复制编辑<br>static final double PI = 3.14159;<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>修饰变量</strong>：变量值不可变（基本类型值不可变，引用类型地址不可变）。</li><li><strong>修饰方法</strong>：防止子类重写方法。</li><li><strong>修饰类</strong>：防止类被继承。</li></ul><p>这样使用 <code>final</code> 主要是为了<strong>保证安全性</strong>、<strong>提高程序的可读性</strong>，并且在某些情况下还能<strong>优化性能</strong>（JVM 可进行编译优化）。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口</title>
      <link href="/2025/03/27/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2025/03/27/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类-vs-接口：对比与选择"><a href="#抽象类-vs-接口：对比与选择" class="headerlink" title="抽象类 vs. 接口：对比与选择"></a><strong>抽象类 vs. 接口：对比与选择</strong></h2><p>抽象类（<code>abstract class</code>）和接口（<code>interface</code>）都是 Java 中用于<strong>定义类的规范</strong>，但它们有一些关键的区别和适用场景。</p><hr><h2 id="1-抽象类和接口的定义"><a href="#1-抽象类和接口的定义" class="headerlink" title="1. 抽象类和接口的定义"></a><strong>1. 抽象类和接口的定义</strong></h2><h3 id="（1）抽象类"><a href="#（1）抽象类" class="headerlink" title="（1）抽象类"></a><strong>（1）抽象类</strong></h3><ul><li><strong>定义</strong>：抽象类是一个不能被实例化的类，通常包含**抽象方法（未实现）**和**普通方法（已实现）**。</li><li><strong>作用</strong>：用于代码复用、定义通用属性和行为，让子类继承。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑abstract class Animal &#123;<br>    String name;<br><br>    Animal(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    abstract void makeSound(); // 抽象方法（子类必须实现）<br><br>    void sleep() &#123; // 普通方法<br>        System.out.println(name + &quot; is sleeping.&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="（2）接口"><a href="#（2）接口" class="headerlink" title="（2）接口"></a><strong>（2）接口</strong></h3><ul><li><strong>定义</strong>：接口是一个完全抽象的类型，<strong>只定义方法的规范</strong>，默认情况下所有方法都是 <code>public abstract</code>（JDK 8+ 之后可有 <code>default</code> 方法）。</li><li><strong>作用</strong>：用于定义行为规范，让不同类实现相同的方法，而不提供默认实现。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑interface Flyable &#123;<br>    void fly(); // 只定义方法，不提供实现<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="2-抽象类-vs-接口的详细对比"><a href="#2-抽象类-vs-接口的详细对比" class="headerlink" title="2. 抽象类 vs. 接口的详细对比"></a><strong>2. 抽象类 vs. 接口的详细对比</strong></h2><table><thead><tr><th>特性</th><th>抽象类（Abstract Class）</th><th>接口（Interface）</th></tr></thead><tbody><tr><td><strong>是否能实例化</strong></td><td>❌ 不能实例化</td><td>❌ 不能实例化</td></tr><tr><td><strong>是否能包含方法实现</strong></td><td>✅ 可以</td><td>✅ JDK 8+ <code>default</code> 方法支持</td></tr><tr><td><strong>是否能包含普通成员变量</strong></td><td>✅ 可以</td><td>❌ 只能有 <code>static final</code> 常量</td></tr><tr><td><strong>是否能有构造方法</strong></td><td>✅ 可以</td><td>❌ 不能</td></tr><tr><td><strong>是否能继承多个类&#x2F;接口</strong></td><td>❌ 只能单继承</td><td>✅ 可以实现多个接口</td></tr><tr><td><strong>默认方法修饰符</strong></td><td><code>public/protected/private</code></td><td><code>public abstract</code>（方法默认 <code>public</code>）</td></tr><tr><td><strong>静态方法</strong></td><td>✅ 允许（JDK 8+）</td><td>✅ 允许（JDK 8+）</td></tr><tr><td><strong>是否适用于代码复用</strong></td><td>✅ 适用于<strong>代码复用</strong></td><td>❌ 主要用于<strong>定义规范</strong></td></tr></tbody></table><hr><h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a><strong>3. 代码示例</strong></h2><h3 id="（1）抽象类示例"><a href="#（1）抽象类示例" class="headerlink" title="（1）抽象类示例"></a><strong>（1）抽象类示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑abstract class Animal &#123;<br>    String name;<br><br>    Animal(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    abstract void makeSound(); // 抽象方法<br><br>    void sleep() &#123; // 具体方法<br>        System.out.println(name + &quot; is sleeping.&quot;);<br>    &#125;<br>&#125;<br><br>class Dog extends Animal &#123;<br>    Dog(String name) &#123;<br>        super(name);<br>    &#125;<br><br>    @Override<br>    void makeSound() &#123;<br>        System.out.println(name + &quot; says: Woof!&quot;);<br>    &#125;<br>&#125;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Dog myDog = new Dog(&quot;Buddy&quot;);<br>        myDog.makeSound(); // 输出：Buddy says: Woof!<br>        myDog.sleep();     // 输出：Buddy is sleeping.<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="（2）接口示例"><a href="#（2）接口示例" class="headerlink" title="（2）接口示例"></a><strong>（2）接口示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑interface Flyable &#123;<br>    void fly();<br>&#125;<br><br>class Bird implements Flyable &#123;<br>    @Override<br>    public void fly() &#123;<br>        System.out.println(&quot;The bird is flying.&quot;);<br>    &#125;<br>&#125;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Flyable myBird = new Bird();<br>        myBird.fly(); // 输出：The bird is flying.<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="（3）抽象类-接口结合"><a href="#（3）抽象类-接口结合" class="headerlink" title="（3）抽象类 + 接口结合"></a><strong>（3）抽象类 + 接口结合</strong></h3><p>一个类可以<strong>同时继承抽象类</strong>并<strong>实现多个接口</strong>，从而获得代码复用和行为扩展的优势。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑abstract class Animal &#123;<br>    String name;<br><br>    Animal(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    abstract void makeSound();<br>&#125;<br><br>// 定义接口<br>interface Flyable &#123;<br>    void fly();<br>&#125;<br><br>// 继承抽象类，同时实现接口<br>class Bird extends Animal implements Flyable &#123;<br>    Bird(String name) &#123;<br>        super(name);<br>    &#125;<br><br>    @Override<br>    void makeSound() &#123;<br>        System.out.println(name + &quot; chirps!&quot;);<br>    &#125;<br><br>    @Override<br>    public void fly() &#123;<br>        System.out.println(name + &quot; is flying.&quot;);<br>    &#125;<br>&#125;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Bird myBird = new Bird(&quot;Sparrow&quot;);<br>        myBird.makeSound(); // 输出：Sparrow chirps!<br>        myBird.fly();       // 输出：Sparrow is flying.<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-什么时候使用抽象类-vs-接口？"><a href="#4-什么时候使用抽象类-vs-接口？" class="headerlink" title="4. 什么时候使用抽象类 vs. 接口？"></a><strong>4. 什么时候使用抽象类 vs. 接口？</strong></h2><p>✅ <strong>使用抽象类</strong></p><ul><li>需要共享<strong>成员变量</strong>或<strong>默认实现</strong></li><li>设计一个<strong>基础类</strong>，不同子类有部分相同逻辑</li><li>需要构造方法（接口没有构造方法）</li><li>适用于 <strong>“是一个（is-a）”</strong> 关系，例如 <code>Dog is an Animal</code></li></ul><p>✅ <strong>使用接口</strong></p><ul><li>只定义<strong>行为规范</strong>（如 <code>Comparable&lt;T&gt;</code>）</li><li>需要<strong>多继承</strong>（Java 只允许单继承，但可实现多个接口）</li><li>适用于 <strong>“能做什么（can-do）”</strong> 关系，例如 <code>Bird can Fly</code></li></ul><hr><h2 id="5-Java-8-的接口增强"><a href="#5-Java-8-的接口增强" class="headerlink" title="5. Java 8+ 的接口增强"></a><strong>5. Java 8+ 的接口增强</strong></h2><p>Java 8+ <strong>接口可以包含默认方法和静态方法</strong>，使其更接近抽象类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑interface Vehicle &#123;<br>    void move();<br><br>    // Java 8+ default 方法<br>    default void startEngine() &#123;<br>        System.out.println(&quot;Engine started.&quot;);<br>    &#125;<br>&#125;<br><br>class Car implements Vehicle &#123;<br>    @Override<br>    public void move() &#123;<br>        System.out.println(&quot;Car is moving.&quot;);<br>    &#125;<br>&#125;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Car myCar = new Car();<br>        myCar.move();        // 输出：Car is moving.<br>        myCar.startEngine(); // 输出：Engine started.<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🔹 <strong>接口的 <code>default</code> 方法</strong> 允许在不破坏已有代码的情况下扩展接口功能。<br> 🔹 <strong>但它仍然不能有成员变量</strong>，适用于行为扩展。</p><hr><h2 id="6-终极总结"><a href="#6-终极总结" class="headerlink" title="6. 终极总结"></a><strong>6. 终极总结</strong></h2><table><thead><tr><th>适用场景</th><th>选择</th></tr></thead><tbody><tr><td>需要共享代码（方法或字段）</td><td><strong>抽象类</strong></td></tr><tr><td>需要定义行为规范，让多个类实现</td><td><strong>接口</strong></td></tr><tr><td>需要构造方法</td><td><strong>抽象类</strong></td></tr><tr><td>需要支持多继承</td><td><strong>接口</strong></td></tr><tr><td>适用于 “is-a” 关系</td><td><strong>抽象类</strong></td></tr><tr><td>适用于 “can-do” 关系</td><td><strong>接口</strong></td></tr></tbody></table><hr><h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a><strong>7. 结论</strong></h2><ul><li><strong>如果只是定义规范</strong>（行为）→ ✅ <strong>使用接口</strong></li><li><strong>如果需要代码复用</strong>（成员变量、默认实现）→ ✅ <strong>使用抽象类</strong></li><li><strong>Java 8+ 的 <code>default</code> 方法</strong> 让接口更像抽象类，但仍不能包含实例变量</li></ul><p><strong>最佳实践</strong>：</p><ul><li><strong>优先使用接口</strong>（避免 Java 单继承的限制）</li><li><strong>如果有共享代码需求，再使用抽象类</strong></li><li><strong>抽象类+接口结合使用，发挥最大优势</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例类</title>
      <link href="/2025/03/27/%E5%8D%95%E4%BE%8B%E7%B1%BB/"/>
      <url>/2025/03/27/%E5%8D%95%E4%BE%8B%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="单例类（Singleton）"><a href="#单例类（Singleton）" class="headerlink" title="单例类（Singleton）"></a>单例类（Singleton）</h2><p>单例模式（Singleton Pattern）是一种常见的设计模式，确保一个类在系统中只有一个实例，并提供一个全局访问点。</p><h3 id="单例模式的特点"><a href="#单例模式的特点" class="headerlink" title="单例模式的特点"></a><strong>单例模式的特点</strong></h3><ol><li><strong>唯一性</strong>：整个系统中该类只有一个实例。</li><li><strong>全局访问</strong>：可以在整个程序中访问这个实例。</li><li><strong>延迟初始化（可选）</strong>：只有在真正需要时才创建实例，提高性能。</li></ol><hr><h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a><strong>单例模式的实现方式</strong></h2><h3 id="1-饿汉式（Eager-Singleton）"><a href="#1-饿汉式（Eager-Singleton）" class="headerlink" title="1. 饿汉式（Eager Singleton）"></a><strong>1. 饿汉式（Eager Singleton）</strong></h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul><li>直接在类加载时创建实例，线程安全。</li><li>缺点是可能会造成资源浪费（如果实例很早创建，但一直未被使用）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public class Singleton &#123;<br>    private static final Singleton INSTANCE = new Singleton(); // 直接创建实例<br><br>    private Singleton() &#123;&#125; // 私有构造方法，防止外部创建对象<br><br>    public static Singleton getInstance() &#123;<br>        return INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-懒汉式（Lazy-Singleton）"><a href="#2-懒汉式（Lazy-Singleton）" class="headerlink" title="2. 懒汉式（Lazy Singleton）"></a><strong>2. 懒汉式（Lazy Singleton）</strong></h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul><li>只有在第一次调用 <code>getInstance()</code> 时才创建实例，避免资源浪费。</li><li>但<strong>非线程安全</strong>，多个线程可能同时创建多个实例。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public class Singleton &#123;<br>    private static Singleton instance;<br><br>    private Singleton() &#123;&#125; // 私有构造方法<br><br>    public static Singleton getInstance() &#123;<br>        if (instance == null) &#123; // 只有在需要时才创建实例<br>            instance = new Singleton();<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题</strong>：多线程环境下，可能出现多个实例。</p><hr><h3 id="3-线程安全的懒汉式"><a href="#3-线程安全的懒汉式" class="headerlink" title="3. 线程安全的懒汉式"></a><strong>3. 线程安全的懒汉式</strong></h3><p><strong>方式 1：使用 synchronized</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public class Singleton &#123;<br>    private static Singleton instance;<br><br>    private Singleton() &#123;&#125;<br><br>    public static synchronized Singleton getInstance() &#123;<br>        if (instance == null) &#123;<br>            instance = new Singleton();<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缺点</strong>：<code>synchronized</code> 影响性能，每次访问都需要加锁。</p><hr><p><strong>方式 2：双重检查锁（Double-Check Locking）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public class Singleton &#123;<br>    private static volatile Singleton instance;<br><br>    private Singleton() &#123;&#125;<br><br>    public static Singleton getInstance() &#123;<br>        if (instance == null) &#123; // 第一次检查<br>            synchronized (Singleton.class) &#123;<br>                if (instance == null) &#123; // 第二次检查<br>                    instance = new Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>volatile</code> 关键字</strong>：防止指令重排，保证可见性。</li><li><strong>双重检查</strong>：避免不必要的加锁，提高性能。</li></ul><hr><h3 id="4-静态内部类（推荐方式）"><a href="#4-静态内部类（推荐方式）" class="headerlink" title="4. 静态内部类（推荐方式）"></a><strong>4. 静态内部类（推荐方式）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public class Singleton &#123;<br>    private Singleton() &#123;&#125;<br><br>    private static class SingletonHolder &#123;<br>        private static final Singleton INSTANCE = new Singleton();<br>    &#125;<br><br>    public static Singleton getInstance() &#123;<br>        return SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>线程安全，利用类加载机制确保实例唯一。</li><li><strong>延迟加载</strong>（Lazy Loading），只有 <code>getInstance()</code> 被调用时，才创建实例。</li></ul><hr><h3 id="5-枚举实现单例（最佳方案）"><a href="#5-枚举实现单例（最佳方案）" class="headerlink" title="5. 枚举实现单例（最佳方案）"></a><strong>5. 枚举实现单例（最佳方案）</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public enum Singleton &#123;<br>    INSTANCE;<br><br>    public void doSomething() &#123;<br>        System.out.println(&quot;Hello Singleton!&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li><strong>线程安全</strong>，由 JVM 保证。</li><li><strong>防止反射攻击</strong>（私有构造方法仍可通过反射破坏单例，但枚举不会）。</li><li><strong>防止反序列化创建新实例</strong>。</li></ul><hr><h2 id="防止反射和序列化破坏单例"><a href="#防止反射和序列化破坏单例" class="headerlink" title="防止反射和序列化破坏单例"></a><strong>防止反射和序列化破坏单例</strong></h2><ol><li><p><strong>防止反射破坏单例</strong></p><ul><li>在构造方法中检测实例是否已存在：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public class Singleton &#123;<br>    private static volatile Singleton instance;<br><br>    private Singleton() &#123;<br>        if (instance != null) &#123;<br>            throw new RuntimeException(&quot;禁止反射创建单例！&quot;);<br>        &#125;<br>    &#125;<br><br>    public static Singleton getInstance() &#123;<br>        if (instance == null) &#123;<br>            synchronized (Singleton.class) &#123;<br>                if (instance == null) &#123;<br>                    instance = new Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        return instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>防止序列化破坏单例</strong></p><ul><li>通过 <code>readResolve()</code> 方法确保反序列化返回同一个实例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑private Object readResolve() &#123;<br>    return instance;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>方式</th><th>是否线程安全</th><th>是否延迟加载</th><th>是否推荐</th></tr></thead><tbody><tr><td>饿汉式</td><td>✅</td><td>❌</td><td>❌（可能浪费资源）</td></tr><tr><td>懒汉式</td><td>❌</td><td>✅</td><td>❌（非线程安全）</td></tr><tr><td>synchronized 懒汉式</td><td>✅</td><td>✅</td><td>❌（影响性能）</td></tr><tr><td>双重检查锁</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>静态内部类</td><td>✅</td><td>✅</td><td>✅（推荐）</td></tr><tr><td>枚举</td><td>✅</td><td>✅</td><td>⭐（最佳方式）</td></tr></tbody></table><p><strong>最佳实践</strong>：优先使用 <strong>枚举</strong> 或 <strong>静态内部类</strong> 实现单例。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>枚举类</title>
      <link href="/2025/03/27/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/2025/03/27/%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类（Enum）"><a href="#枚举类（Enum）" class="headerlink" title="枚举类（Enum）"></a><strong>枚举类（Enum）</strong></h2><h3 id="1-什么是枚举类？"><a href="#1-什么是枚举类？" class="headerlink" title="1. 什么是枚举类？"></a><strong>1. 什么是枚举类？</strong></h3><p>枚举（<code>enum</code>）是一种特殊的类，表示一组固定的常量。它在 Java、C++、Python 等编程语言中广泛应用，通常用于定义状态、类型、方向等不可变值。</p><hr><h3 id="2-Java-枚举的基本使用"><a href="#2-Java-枚举的基本使用" class="headerlink" title="2. Java 枚举的基本使用"></a><strong>2. Java 枚举的基本使用</strong></h3><p>Java 枚举使用 <code>enum</code> 关键字定义，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public enum Color &#123;<br>    RED, GREEN, BLUE;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><code>enum</code> 实际上是一个类，继承自 <code>java.lang.Enum</code>。</li><li>枚举的实例是<strong>固定的、有限的</strong>，不能通过 <code>new</code> 创建新实例。</li><li>每个枚举值本质上是 <code>Color</code> 类的一个静态实例。</li></ul><p><strong>使用示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑Color c = Color.RED;<br>System.out.println(c); // 输出：RED<br></code></pre></td></tr></table></figure><hr><h3 id="3-枚举类的常见用法"><a href="#3-枚举类的常见用法" class="headerlink" title="3. 枚举类的常见用法"></a><strong>3. 枚举类的常见用法</strong></h3><h4 id="（1）枚举类中定义属性和方法"><a href="#（1）枚举类中定义属性和方法" class="headerlink" title="（1）枚举类中定义属性和方法"></a><strong>（1）枚举类中定义属性和方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public enum Status &#123;<br>    SUCCESS(200, &quot;OK&quot;),<br>    ERROR(500, &quot;Server Error&quot;),<br>    NOT_FOUND(404, &quot;Not Found&quot;);<br><br>    private final int code;<br>    private final String message;<br><br>    // 构造方法（必须是 private）<br>    private Status(int code, String message) &#123;<br>        this.code = code;<br>        this.message = message;<br>    &#125;<br><br>    public int getCode() &#123;<br>        return code;<br>    &#125;<br><br>    public String getMessage() &#123;<br>        return message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑System.out.println(Status.SUCCESS.getCode());    // 输出：200<br>System.out.println(Status.SUCCESS.getMessage()); // 输出：&quot;OK&quot;<br></code></pre></td></tr></table></figure><hr><h4 id="（2）枚举类中的抽象方法"><a href="#（2）枚举类中的抽象方法" class="headerlink" title="（2）枚举类中的抽象方法"></a><strong>（2）枚举类中的抽象方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public enum Operation &#123;<br>    ADD &#123;<br>        @Override<br>        public int apply(int a, int b) &#123;<br>            return a + b;<br>        &#125;<br>    &#125;,<br>    SUBTRACT &#123;<br>        @Override<br>        public int apply(int a, int b) &#123;<br>            return a - b;<br>        &#125;<br>    &#125;;<br><br>    public abstract int apply(int a, int b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑int result = Operation.ADD.apply(5, 3); // 5 + 3 = 8<br>System.out.println(result);<br></code></pre></td></tr></table></figure><hr><h4 id="（3）遍历枚举值"><a href="#（3）遍历枚举值" class="headerlink" title="（3）遍历枚举值"></a><strong>（3）遍历枚举值</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑for (Color c : Color.values()) &#123;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">nginx复制编辑RED<br>GREEN<br>BLUE<br></code></pre></td></tr></table></figure><hr><h4 id="（4）枚举类的-valueOf-方法"><a href="#（4）枚举类的-valueOf-方法" class="headerlink" title="（4）枚举类的 valueOf 方法"></a><strong>（4）枚举类的 <code>valueOf</code> 方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑Color c = Color.valueOf(&quot;RED&quot;);<br>System.out.println(c); // 输出：RED<br></code></pre></td></tr></table></figure><ul><li><code>valueOf(&quot;RED&quot;)</code> 必须匹配 <code>enum</code> 中的名称（区分大小写）。</li><li>如果传入 <code>&quot;red&quot;</code>，会抛出 <code>IllegalArgumentException</code>。</li></ul><hr><h3 id="4-枚举实现单例模式（推荐）"><a href="#4-枚举实现单例模式（推荐）" class="headerlink" title="4. 枚举实现单例模式（推荐）"></a><strong>4. 枚举实现单例模式（推荐）</strong></h3><p>枚举是实现单例模式的最佳方式，<strong>线程安全</strong>、<strong>防止反射破坏</strong>、<strong>防止序列化破坏</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java复制编辑public enum Singleton &#123;<br>    INSTANCE;<br><br>    public void doSomething() &#123;<br>        System.out.println(&quot;Hello, Singleton!&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java<br><br><br>复制编辑<br>Singleton.INSTANCE.doSomething();<br></code></pre></td></tr></table></figure><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>继承</td><td><code>enum</code> 默认继承 <code>java.lang.Enum</code>，不能再继承其他类</td></tr><tr><td>线程安全</td><td><code>enum</code> 本质上是 <code>final</code>，且实例是静态的，天然线程安全</td></tr><tr><td>构造方法</td><td>必须是 <code>private</code>，外部不能 <code>new</code> 构造</td></tr><tr><td>反射安全</td><td>反射无法创建新的 <code>enum</code> 实例</td></tr><tr><td>序列化安全</td><td><code>enum</code> 反序列化时不会创建新对象，保证单例</td></tr></tbody></table><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul><li><strong>定义常量集合</strong>（如 HTTP 状态码、星期、颜色等）</li><li><strong>替代 <code>switch-case</code> 语句中的字符串或整数</strong></li><li><strong>实现策略模式</strong></li><li><strong>单例模式（推荐使用）</strong></li></ul><p>枚举不仅仅是常量的集合，它可以包含方法、构造函数，甚至实现接口，使其更加强大和灵活。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2025/03/25/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/25/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-0标题"><a href="#1-0标题" class="headerlink" title="1.0标题"></a>1.0标题</h2><p>语法展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure><hr><h2 id="2-0字体"><a href="#2-0字体" class="headerlink" title="2.0字体"></a>2.0字体</h2><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*斜体文本*<br>**粗体文本**<br>***粗斜体文本***<br></code></pre></td></tr></table></figure><p><em>斜体</em></p><p><strong>粗体</strong></p><p><em><strong>粗斜体</strong></em></p><hr><h2 id="3-0分割线"><a href="#3-0分割线" class="headerlink" title="3.0分割线"></a>3.0分割线</h2><p>分割线可以让文章变得更加有层次感，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">***<br>----------<br>_ _ _<br></code></pre></td></tr></table></figure><hr><h2 id="4-0删除线"><a href="#4-0删除线" class="headerlink" title="4.0删除线"></a>4.0删除线</h2><p>给文本加上删除线，在文本两端使用两个波浪线<code>~</code>，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">~~文本~~<br></code></pre></td></tr></table></figure><p>例如：<del>文本</del></p><hr><h2 id="5-0列表"><a href="#5-0列表" class="headerlink" title="5.0列表"></a>5.0列表</h2><p>列表分为无序和有序</p><hr><h3 id="5-1无序列表"><a href="#5-1无序列表" class="headerlink" title="5.1无序列表"></a>5.1无序列表</h3><p>无序列表使用星号<code>*</code>、加号 <code>+</code>、减号 <code>-</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">* 第一项<br>* 第二项<br>* 第三项<br><br>+ 第一项<br>+ 第二项<br>+ 第三项<br><br><br>- 第一项<br>- 第二项<br>- 第三项<br></code></pre></td></tr></table></figure><p>例如：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><hr><h3 id="5-2有序列表"><a href="#5-2有序列表" class="headerlink" title="5.2有序列表"></a>5.2有序列表</h3><p>有序列表很简单，就是数字加上<code>.</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1. 第一项<br>2. 第二项<br>3. 第三项<br></code></pre></td></tr></table></figure><p>例如：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><hr><h3 id="5-3列表嵌套"><a href="#5-3列表嵌套" class="headerlink" title="5.3列表嵌套"></a>5.3列表嵌套</h3><p>无序和有序可以一起使用，只需要在子列表的选项添加四个空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1. 第一项：<br>    - 子列表1<br>    - 子列表2<br>2. 第二项：<br>    - 子列表1<br>    - 子列表2<br></code></pre></td></tr></table></figure><hr><h2 id="6-0区块"><a href="#6-0区块" class="headerlink" title="6.0区块"></a>6.0区块</h2><p>区块是用来引用的，比如链接或者一段文本</p><p>在段落的开头使用<code>&gt;</code>符号，使用空格，隔开文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt; 引用的内容<br>&gt;<br>&gt; 第二段引用的内容<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">https://source.fomal.cc/img/default_cover_1.webp<br></code></pre></td></tr></table></figure></blockquote><p>在引用里面也是分段落的，我们不是使用回车，而是使用<code>&gt;</code>成单个一行</p><hr><h3 id="6-1区块嵌套"><a href="#6-1区块嵌套" class="headerlink" title="6.1区块嵌套"></a>6.1区块嵌套</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt; 引用<br>&gt;&gt; 2<br>&gt;&gt;<br>&gt;&gt;&gt;3<br></code></pre></td></tr></table></figure><hr><h2 id="7-0代码块"><a href="#7-0代码块" class="headerlink" title="7.0代码块"></a>7.0代码块</h2><p>这是一个程序员专用的语法，代码块可以展示不同语言的代码，代码块语法如下:上下使用三个点进行包裹，最顶上的可以写上代码的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">```javascript<br>$(document).ready(function () &#123;<br>    alert(&#x27;RUNOOB&#x27;);<br>&#125;);<br>```<br></code></pre></td></tr></table></figure><hr><h2 id="8-0链接"><a href="#8-0链接" class="headerlink" title="8.0链接"></a>8.0链接</h2><p>插入链接有两种方式：</p><ul><li>第一种：直接插入</li></ul><p><a href="https://selimn0802.github.io/">https://selimn0802.github.io/</a></p><p>这种方式适用于短的链接，但是过长的链接可能会看起来不得当</p><ul><li>第二种：使用markdown语法插入</li></ul><p>其实就是让一段文本，拥有跳转功能</p><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[链接名称](链接地址)<br><br>或者<br><br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[Firefly](https://selimn0802.github.io/)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;https://selimn0802.github.io/&gt;<br></code></pre></td></tr></table></figure><p><a href="https://selimn0802.github.io/">Firefly</a></p><p><a href="https://selimn0802.github.io/">https://selimn0802.github.io/</a></p><hr><h2 id="9-0图片"><a href="#9-0图片" class="headerlink" title="9.0图片"></a>9.0图片</h2><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">![图片描述](图片的链接)<br></code></pre></td></tr></table></figure><p><img src="https://source.fomal.cc/img/default_cover_1.webp" alt="原神"></p><hr><h2 id="10-0表格"><a href="#10-0表格" class="headerlink" title="10.0表格"></a>10.0表格</h2><p>在markdown里面是可以插入表格的，可以体现一些数据</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">|  表头   | 表头  |<br>|  ----  | ----  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br></code></pre></td></tr></table></figure><hr><h3 id="10-1表格对齐"><a href="#10-1表格对齐" class="headerlink" title="10.1表格对齐"></a>10.1表格对齐</h3><ul><li>居右<code>-:</code></li><li>居左<code>:-</code></li><li>居中<code>:-:</code></li></ul><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">| 左对齐 | 右对齐 | 居中对齐 |<br>| :-----| ----: | :----: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |<br></code></pre></td></tr></table></figure><hr><h2 id="11-0转义字符"><a href="#11-0转义字符" class="headerlink" title="11.0转义字符"></a>11.0转义字符</h2><p>因为在markdown的语法里面，用了一些特定的符号作为语法，如果我们想输出符号，而不是被识别成语法，就需要使转义字符，只需要使用反斜杠，然后加上下面的某个符号即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\   反斜线<br>`   反引号<br>*   星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   感叹号<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/23/hello-world/"/>
      <url>/2025/03/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
